// Generated by redfish-codegen. Do not modify.

{{#defaultPrivileges}}
/// The default privileges required for accessing {{componentName}} instances.
pub struct DefaultPrivileges;
impl redfish_core::privilege::OperationPrivilegeMapping for DefaultPrivileges {
    type Get = {{{get}}};
    type Head = {{{head}}};
    type Post = {{{post}}};
    type Put = {{{put}}};
    type Patch = {{{patch}}};
    type Delete = {{{delete}}};
}

{{/defaultPrivileges}}
{{#subordinatePrivilegeOverrides}}
/// The privileges required for accessing [{{owningComponentName}}][{{owningComponent}}] instances as properties of
/// a {{componentName}} instance.
pub struct {{owningComponentName}}Privileges;
{{#privileges}}
impl redfish_core::privilege::OperationPrivilegeMapping for {{owningComponentName}}Privileges {
    type Get = {{{get}}};
    type Head = {{{head}}};
    type Post = {{{post}}};
    type Put = {{{put}}};
    type Patch = {{{patch}}};
    type Delete = {{{delete}}};
}
{{/privileges}}

{{/subordinatePrivilegeOverrides}}
/// This endpoint implements the {{componentName}} component.
{{#hasOwningComponents}}
///
/// It can be mounted on the following components:
{{/hasOwningComponents}}
{{#owningComponents}}
/// * [{{componentName}}][{{componentType}}]
{{/owningComponents}}
pub struct {{componentName}}<S, P>
where
    S: Clone,
{
    router: axum::routing::MethodRouter<S>,
    privilege_marker: std::marker::PhantomData<fn() -> P>,
    allowed_methods: Vec<axum::http::method::Method>,
{{#isCollection}}
    members_router: axum::routing::MethodRouter<S>,
{{/isCollection}}
{{#subcomponents}}
    {{snakeCaseName}}: Option<axum::Router<S>>,
{{/subcomponents}}
{{#actions}}
    {{snakeCaseName}}: Option<axum::routing::MethodRouter<S>>,
{{/actions}}
}

{{#defaultPrivileges}}
impl<S> Default for {{componentName}}<S, DefaultPrivileges>
where
    S: Clone,
{
    fn default() -> Self {
        Self {
            router: Default::default(),
            privilege_marker: Default::default(),
            allowed_methods: Vec::new(),
{{#isCollection}}
            members_router: Default::default(),
{{/isCollection}}
{{#subcomponents}}
            {{snakeCaseName}}: Default::default(),
{{/subcomponents}}
{{#actions}}
            {{snakeCaseName}}: Default::default(),
{{/actions}}
        }
    }
}
{{/defaultPrivileges}}

impl<S, P> {{componentName}}<S, P>
where
    S: AsRef<dyn redfish_core::auth::AuthenticateRequest> + Clone + Send + Sync + 'static,
    P: redfish_core::privilege::OperationPrivilegeMapping + 'static,
{{#privilegedOperations}}
    <P as redfish_core::privilege::OperationPrivilegeMapping>::{{privilege}}: Send,
{{/privilegedOperations}}
{
{{#operations}}
    pub fn {{snakeCaseName}}<H, T>(mut self, handler: H) -> Self
    where
        H: axum::handler::Handler<T, S, axum::body::Body>,
        T: 'static,
    {
        let operation = axum::routing::{{snakeCaseName}}(
            |{{#requiresAuth}}auth: redfish_core::extract::RedfishAuth<P::{{pascalCaseName}}>,{{/requiresAuth}}
             axum::extract::State(state): axum::extract::State<S>,
             mut request: axum::http::Request<axum::body::Body>| async {
{{#requiresAuth}}
                request.extensions_mut().insert(auth.user);
{{/requiresAuth}}
{{^requiresAuth}}
                request.extensions_mut().insert(Option::<redfish_core::auth::AuthenticatedUser>::None);
{{/requiresAuth}}
                handler.call(request, state).await
            },
        );
{{#isCollection}}
{{#isPost}}
        self.members_router = self.members_router.post(operation.clone());
{{/isPost}}
{{/isCollection}}
        self.router = self.router.{{snakeCaseName}}(operation);
        self.allowed_methods.push(axum::http::method::Method::{{upperSnakeCaseName}});
        self
    }

{{/operations}}
{{#subcomponents}}
    /// Serves an instance of a [{{pascalCaseName}}][{{componentType}}].
    pub fn {{snakeCaseName}}(mut self, {{snakeCaseName}}: axum::Router<S>) -> Self {
        self.{{snakeCaseName}} = Some({{snakeCaseName}});
        self
    }

{{/subcomponents}}
{{#actions}}
    /// Perform the {{pascalCaseName}} operation on this {{componentName}} instance.
    pub fn {{snakeCaseName}}<H, T>(mut self, handler: H) -> Self
    where
        H: axum::handler::Handler<T, S, axum::body::Body>,
        T: 'static,
    {
        self.{{snakeCaseName}} = Some(axum::routing::post(
            |auth: redfish_core::extract::RedfishAuth<P::Post>,
             axum::extract::State(state): axum::extract::State<S>,
             mut request: axum::http::Request<axum::body::Body>| async {
                request.extensions_mut().insert(auth.user);
                handler.call(request, state).await
            },
        ));
        self
    }

{{/actions}}
    pub fn into_router(self) -> axum::Router<S> {
        let Self {
            router,
            mut allowed_methods,
{{#isCollection}}
            members_router,
{{/isCollection}}
{{#subcomponents}}
            {{snakeCaseName}},
{{/subcomponents}}
{{#actions}}
            {{snakeCaseName}},
{{/actions}}
            ..
        } = self;
        let result = axum::Router::default();
{{#subcomponents}}
        let result = match {{snakeCaseName}} {
            Some(router) => result.nest("{{componentPath}}", router),
            None => result,
        };
{{/subcomponents}}
{{#actions}}
        let result = match {{snakeCaseName}} {
            Some(router) => result.route("/Actions/{{componentName}}.{{pascalCaseName}}", router),
            None => result,
        };
{{/actions}}
{{#isCollection}}
        let result = result.route(
            "/Members",
            members_router.fallback(|| async {
                (
                    axum::http::StatusCode::METHOD_NOT_ALLOWED,
                    axum::Json(redfish_core::error::one_message(
                        redfish_core::convert::IntoRedfishMessage::into_redfish_message(
                            {{baseRegistry}}::OperationNotAllowed))),
                )
            })
        );
{{/isCollection}}
        allowed_methods.dedup();
        let allow_header = allowed_methods
            .into_iter()
            .map(|method| method.to_string())
            .reduce(|one, two| one + "," + &two)
            .unwrap();
        result.route(
            "/",
            router.fallback(|| async {
                (
                    axum::http::StatusCode::METHOD_NOT_ALLOWED,
                    axum::Json(redfish_core::error::one_message(
                        redfish_core::convert::IntoRedfishMessage::into_redfish_message(
                            {{baseRegistry}}::OperationNotAllowed))),
                )
            })
            .route_layer(axum::middleware::from_fn_with_state(
                allow_header,
                |axum::extract::State(allow_header): axum::extract::State<String>,
                 request: axum::http::Request<axum::body::Body>,
                 next: axum::middleware::Next<axum::body::Body>| async move {
                    let apply_allow = matches!(*request.method(), axum::http::Method::GET | axum::http::Method::HEAD);
                    let mut response = next.run(request).await;
                    if apply_allow && !response.headers().contains_key(axum::http::header::ALLOW) {
                        response.headers_mut().insert(
                            axum::http::header::ALLOW,
                            axum::http::HeaderValue::from_str(&allow_header).unwrap(),
                        );
                    }
                    response
                },
            )),
        )
    }
}
