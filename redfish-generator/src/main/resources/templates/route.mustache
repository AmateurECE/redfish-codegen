// Generated by redfish-codegen. Do not modify.
// Author: Ethan D. Twardy <ethan.twardy@gmail.com>
//
// Copyright 2023, Ethan Twardy. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

{{#moduleContext}}
{{#imports}}
use {{{path}}};
{{/imports}}
{{/moduleContext}}

use axum::{extract::State, http::StatusCode, response::IntoResponse, routing, Json};

pub struct {{name}}(routing::MethodRouter);

impl Systems {
    pub fn new<S>(state: S) -> Self
    where
        S: {{trait}}
{{#isPrivileged}}
             + AsRef<dyn auth::AuthenticateRequest>
{{/isPrivileged}}
             + Send + Sync + Clone + 'static,
    {
        let router = routing::MethodRouter::new()
{{#operations}}
            .{{name}}(
                |State({{#mutable}}mut {{/mutable}}state): State<S>,
{{#isPrivileged}}
                _: extract::RedfishAuth<{{privilege}}>,
{{/isPrivileged}}
{{#body}}
                Json(body): Json<{{type}}>,
{{/body}}
{{#parameters}}
                Path({{name}}): Path<{{type}}>,
{{/parameters}}
                | async move {
                    match state.{{name}}(
{{#parameters}}
                        {{name}},
{{/parameters}}
{{#body}}
                        body,
{{/body}}
                    ) {
{{#responseVariants}}
                        {{identifier}}{{#hasArgs}}({{/hasArgs}}
{{#args}}
                                             {{name}},
{{/args}}
                                {{#hasArgs}}){{/hasArgs}} => (
                            {{statusCode}},
                            {{#hasHeaders}}[{{/hasHeaders}}
{{#headers}}
                                            ("{{{name}}}", {{{content}}}),
{{/headers}}
                            {{#hasHeaders}}],{{/hasHeaders}}
                            Json(response)
                        ).into_response(),
{{/responseVariants}}
                    }
                })
{{/operations}}
            .with_state(state);
        Systems(router)
    }
}

impl Into<routing::MethodRouter> for {{name}} {
    fn into(self) -> routing::MethodRouter {
        self.0
    }
}
